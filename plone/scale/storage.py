"""
Image storage
=============

Storage and retrieval of images is abstracted, allowing different
implementations to be used.

Scales can be retrieved using either their scaling parameters or via an
identification code generated by the storage.
"""

import UserDict
from zope.interface import Attribute
from zope.interface import Interface
from zope.interface import implements

class IImageScale(Interface):
    """A scaled image. This is a very simple wrapper around an image scale
    which gives access to its metadata.

    The `id` attribute is usually only guaranteed to be unique within the
    context of a specific original image. For certain storage implementations
    it may be globally unique as well.
    """

    id = Attribute("An identifier uniquely identifying this scale")
    dimensions = Attribute("A (width, height) tuple with the image dimensions.")
    url = Attribute("Absolute URL for this image.")
    mimetype = Attribute("The MIME-type of the image.")
    size = Attribute("The size of the image data in bytes.")



class IImageScaleStorage(Interface):
    """This is an adapter for an image which can store, retrieve and generate
    image scales. It provides a dictionary interface to existing image scales
    using the scale id as key. To find or create a scale based on its scaling
    parameters use the `:func:getScale` method.
    """

    def __init__(image):
        """Adapter constructor."""


    def getScale(width=None, height=None, direction=None, create=True):
        """Find a scale based on its parameters. The parameters can be anything
        supported by `:func:scaleImage`. If an existing scale is found it is
        returned in an `:obj:IImageScale` wrapper. If the scale does not exists
        it will be created, unless `create` is `False` in which case `None`
        will be returned instead.
        """

    def __getitem__(self, key):
        """Find a scale based on its id."""



class BaseAnnotationStorage(UserDict.DictMixin):
    """:obj:`IImageScaleStorage` implementation using annotations. Image data
    is stored as an annotation on the object container the image. This is
    needed since not all images are themselves annotatable.

    The image scales are stored as dictionaries in an annotation with
    `plone.scale.<field>.<id>` as key. Each image scale dictionary has the
    following keys:

    * dimensions: A (width, height) tuple with the image dimensions.
    * mimetype: the MIME type of the image
    * size: size of the image data in bytes
    * data: the raw image data

    In addition a list of all image scales and their parameters are maintained
    in an annotation with key `plone.scale.<field>`. This makes it possible to
    find an existing scale with specific parameters without having to iterate
    over all scales.

    This is a base class for adapters. Derived classes need to implement
    a constructor which puts the field name in `self.fieldname` and sets 
    `self.annotations` to the appropriate annotation of the content object.
    """
    # Extra implementation note: the list of scales is kept as a list of
    # (id, scale parameter) tuples. This is not as ideal as a mapping of
    # parameters to id would be (since parameter->id lookup is the most
    # common operation), but dicts are not hashable making this impossible.

    implements(IImageScaleStorage)

    def __repr__(self):
        return "<%s fieldname=%s>" % (self.__class__.__name__, self.fieldname)
    __str__ = __repr__

    def _AnnotationKey(self, id):
        """Determine the annotation key for an image scale with id `id`."""
        return "plone.scale.%s.%s" % (self.fieldname, id)
    
    def __getitem__(self, id):
        return self.annotations[self._AnnotationKey(id)]

    def __setitem__(self, id, scale):
        raise RuntimeError("New scales have to be created via getScale()")

    def __delitem__(self, id):
        key=self._AnnotationKey(id)
        del self.annotations[key]
        index=self.annotations["plone.scale.%s" % self.fieldname]
        for i in xrange(len(index)):
            if index[i][0]==id:
                del index[i]
                break

    def __iter__(self):
        key="plone.scale.%s" % self.fieldname
        for (id, _) in self.annotations.get(key, []):
            yield id

    def keys(self):
        return list(self.__iter__())

    def has_key(self, id):
        key=self._AnnotationKey(id)
        return self.annotations.has_key(key)

    __contains__ = has_key

